#include <iostream>
using namespace std;
struct Node{ // Создаем структуру Ноды, 
    Node *next;  // указатель некст
    int val; // переменная валью
    Node(){ // конструктур Ноды без параметров
        this->val = 0; // по умолчанию валью 0 
        this->next = 0; // по умолчанию указатель налл
    }
    Node(int val){ // Конструктор ноды с параметром валью
        this->val = val;   // валью равен данному валью
        this->next = 0; // указатель пока налл
    }
};
struct LinkedList{ // Создаем структуру Линкед Листа
    int size = 0; // в котором начальный размер равен 0
    Node *head; //Создаем ноду голова в Линкед листе 
    Node *tail; // Создаем ноду хвостик в Линкед Листе
    LinkedList(){
        this->head = 0; // По умолчанию  голвушка равен 0
        this->tail = 0; // хвостик тоже равен 0
    }
    void push_back(int val){ //затем мы короче длолжны пуш бэкать какойто валью в список
        if(size == 0){  // если сайз равен нулю
            push_front(val); // то тогда засовываем его в вектор
            return; // заканчиваем цикл
        }
        Node *tmp = new Node(val); // Создаем новый временный указатель на этот вал 
        this->tail->next = tmp;  // теперь в коннце после хвостика стоит этот темп
        this->tail = tmp;   // и темп такой крутой что забирает хвостик себе
        size++; // затем говорим что уже все этот вал наш, и увеличиваем сайз
 }
     void push_front(int val){ // пуш на начало
        Node *tmp = new Node(val); // ноду временная
        this->head = tmp; // головушка теперь этот тмп
        if(size == 0 ){ // сайз если 0
            this->tail = tmp; // то хвостик этот тмп
            this->head = tmp;  // головушка этот тмп
        }
        size+=1; // сайз увеличиваем
    }
    int get_nearest(int k){ // дальше нам нужно принять какую то цифру чтобы проверить его индекс
        Node *cur = this->head;  // создаем временную ноду которая будет показывать на какой ноде мы находимся, начинается она с голвушки
        int min = abs(k-cur->val), offset = 0,i = 0; // затем создаем мин которая берет абс валюю от разницы между числом заданным и числами в листе, индекст = 0, итерация тоже 0.
        while(cur){ //  пока кур у нас не налл
             if((abs(k-cur->val)<min)){ // если наш абс вал от заданного числа менньше чем мин
                  min = abs(k-cur->val); // мин равняется этому числу
                  offset = i; // и сохраняем итерацию то есть индекс
        }
            cur = cur->next; // и двигаемся дальше по закнчиванию нашего условия
            i++; // увеливаем итерацию
    }
    return offset; // возврщааем индекс
}
};
int main(){
    LinkedList *ll = new LinkedList(); // создаем  линкед лист
    int n,l; // создаем валью как размер массива и заданное число
    cin >> n;
    while(n--){
        int a;
        cin >> a;
        ll->push_back(a); // пока вводим числа пусть оно добавлестя в ноду
    }
    cin >> l;
    cout << ll->get_nearest(l) << endl; // воодим заданное число и ищем самое ближайщее число, выводим индекс
    return 0;
}